//
// Created by benea on 25-3-5.
//

#include "mpu6050.h"
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <../Inc/usart.h>



// 加速度计量程分辨率 (LSB/g)
static const float aRes[] = {
    16384.0, // ±2g
    8192.0,  // ±4g
    4096.0,  // ±8g
    2048.0   // ±16g
};

// 陀螺仪量程分辨率 (LSB/°/s)
static const float gRes[] = {
    131.0,   // ±250°/s
    65.5,    // ±500°/s
    32.8,    // ±1000°/s
    16.4     // ±2000°/s
};

typedef struct PFP {
	float pf[3];
} PFP;

PFP pfp_g;
PFP pfp_a;

typedef struct {
	float angle;      // 融合后的最优角度估计
	float rate;       // 角速度（用于预测）
	float P[2][2];    // 协方差矩阵（包含角度和角速度噪声）
	float Q_angle;    // 过程噪声 - 角度（陀螺仪积分噪声）
	float Q_rate;     // 过程噪声 - 角速度（陀螺仪白噪声）
	float R_angle;    // 测量噪声（加速度计噪声）
} KalmanFilter;
KalmanFilter kf_pitch;
KalmanFilter kf_roll;
void Kalman_Init(KalmanFilter *kf);

//以下是用于零点矫正的函数（加速度计）
float zgx;
float zgy;
float zgz;

// 初始化MPU6050
/**
 * 初始化指定MPU6050实例。不需要先对*hmpu参数赋初始值（这个函数会自动进行这项工作）。请注意，如果要使用MPU6050的DMP功能进行姿态解算，不要使用该函数进行初始化。应使用MPU6050_DMP_Init()函数。
 * @param hmpu 要初始化的MPU6050实例结构体。
 * @param hi2c 要初始化的MPU6050正连接到的硬件I2C实例结构体。
 * @param aScl 要选择的加速度量程。
 * @param gScl 要选择的角速度量程。
 * @return 是否成功（用== HAL_OK来判断）
 */
uint8_t myMPU6050_Init(MPU6050_HandleTypeDef *hmpu, I2C_HandleTypeDef *hi2c,
                     enum ACC_SCALE aScl, enum GYRO_SCALE gScl) {
	zgx=0;
	zgy=0;
	zgz=0;
  hmpu->hi2c = hi2c;
  hmpu->Address = MPU6050_ADDR;
  hmpu->aScale = aScl;
  hmpu->gScale = gScl;

  // 唤醒设备
  uint8_t check;
  HAL_I2C_Mem_Read(hmpu->hi2c, hmpu->Address, WHO_AM_I, 1, &check, 1, 100);
  if(check != 0x68) return HAL_ERROR;

  // 配置电源管理
  uint8_t data = 0x03; // 使用Z轴陀螺仪时钟(8kHz)
  HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, PWR_MGMT_1, 1, &data, 1, 100);

  // 设置采样率(500Hz)
  data = 0x0F;
  HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, SMPLRT_DIV, 1, &data, 1, 100);

	/*
  // 配置低通滤波器(42Hz)
  data = 0x03;
  HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, CONFIG, 1, &data, 1, 100);*/

  // 配置加速度计量程
  data = (hmpu->aScale << 3);
  HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, ACCEL_CONFIG, 1, &data, 1, 100);

  // 配置陀螺仪量程
   data = (hmpu->gScale << 3);
	HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, GYRO_CONFIG, 1, &data, 1, 100);
	MPU6050_MyCalibrate(hmpu);
	Kalman_Init(&kf_pitch);
	Kalman_Init(&kf_roll);

  return HAL_OK;
}

// 读取原始数据
/**
 * 向指定缓存读取MPU6050的基本数据（角速度、加速度、温度）。
 * @param hmpu 要读取的MPU6050实例结构体。
 * @param accel 要读取到的加速度缓冲结构体指针。
 * @param gyro 要读取到的角速度缓冲结构体指针。
 * @param temp 要读取到的温度缓冲结构体指针。
 */
void MPU6050_ReadRawData(MPU6050_HandleTypeDef *hmpu, int16_t *accel, int16_t *gyro, int16_t *temp) {
  uint8_t buffer[14];

  // 读取所有传感器数据寄存器
  HAL_I2C_Mem_Read(hmpu->hi2c, hmpu->Address, ACCEL_XOUT_H, 1, buffer, 14, 100);

  // 组合加速度计数据
  accel[0] = (int16_t)((buffer[0] << 8) | buffer[1]);
  accel[1] = (int16_t)((buffer[2] << 8) | buffer[3]);
  accel[2] = (int16_t)((buffer[4] << 8) | buffer[5]);

  // 温度数据
  *temp = (int16_t)((buffer[6] << 8) | buffer[7]);

  // 组合陀螺仪数据
  gyro[0] = (int16_t)((buffer[8] << 8) | buffer[9]);
  gyro[1] = (int16_t)((buffer[10] << 8) | buffer[11]);
  gyro[2] = (int16_t)((buffer[12] << 8) | buffer[13]);
}

// 读取处理后的数据
/**
 * 读取处理后的，封装后的MPU6050的基本数据（角速度、加速度、温度）。加速度单位为g，角速度单位°/s
 * 这个函数读取到的数据是已经经过零点校正后的数据。
 * ！！注意！！不校正加速度计Z轴的数据！！
 * @param hmpu 要读取的MPU6050实例结构体。
 * @param data 要读取到的数据结构体缓冲指针。
 */
void MPU6050_ReadProcessedData(MPU6050_HandleTypeDef *hmpu, MPU6050_Data *data) {
  int16_t accelRaw[3], gyroRaw[3], tempRaw;

  MPU6050_ReadRawData(hmpu, accelRaw, gyroRaw, &tempRaw);

  // 应用校准偏移
  for(int i=0; i<3; i++) {
    accelRaw[i] -= hmpu->Accel_Offset[i];
    gyroRaw[i] -= hmpu->Gyro_Offset[i];
  }

  // 转换加速度计数据
  data->Accel_X = (float)accelRaw[0] / aRes[hmpu->aScale];
  data->Accel_Y = (float)accelRaw[1] / aRes[hmpu->aScale];
  data->Accel_Z = (float)accelRaw[2] / aRes[hmpu->aScale];

  // 转换陀螺仪数据
  data->Gyro_X = (float)gyroRaw[0] / gRes[hmpu->gScale] - zgx;
  data->Gyro_Y = (float)gyroRaw[1] / gRes[hmpu->gScale] - zgy;
  data->Gyro_Z = (float)gyroRaw[2] / gRes[hmpu->gScale] - zgz;

  // 转换温度数据
  data->Temp = (float)tempRaw / 340.0 + 36.53;
}

// 校准传感器
/**
 * 对指定的MPU6050进行校准。注意，该校准用于消除零偏稳态误差，因此务必保证校准时不要移动MPU6050！
 *  * ！！注意！！不校正加速度计Z轴的数据！！
 * @param hmpu 要进行校准的MPU6050实例。
 * @param sampleCount 进行校准的次数。
 */
void MPU6050_Calibrate(MPU6050_HandleTypeDef *hmpu, uint16_t sampleCount) {
  int32_t accelSum[3] = {0}, gyroSum[3] = {0};

  for(uint16_t i=0; i<sampleCount; i++) {
    int16_t accelRaw[3], gyroRaw[3], temp;
    MPU6050_ReadRawData(hmpu, accelRaw, gyroRaw, &temp);

    for(int j=0; j<3; j++) {
      accelSum[j] += accelRaw[j];
      gyroSum[j] += gyroRaw[j];
    }
    HAL_Delay(2);
  }

  for(int j=0; j<3; j++) {
    hmpu->Gyro_Offset[j] = gyroSum[j] / sampleCount;
  }
	for(int j=0; j<2; j++) {
		hmpu->Accel_Offset[j] = accelSum[j] / sampleCount;
	}
}

// 测试设备连接
HAL_StatusTypeDef MPU6050_TestConnection(MPU6050_HandleTypeDef *hmpu) {
  uint8_t whoami;
  HAL_StatusTypeDef status = HAL_I2C_Mem_Read(hmpu->hi2c, hmpu->Address, WHO_AM_I, 1, &whoami, 1, 100);
  return (status == HAL_OK) && (whoami == 0x68) ? HAL_OK : HAL_ERROR;
}








float DT = 1.0f/500;


float MPU6050_getDT() {
	return DT;
}

float MPU6050_setDT(float dt) {
	DT = dt;
	return dt;
}


void MPU6050_init_estimator(AttitudeEstimator* est,MPU6050_Data *data) {
    est->q[0] = 1.0f;
    est->q[1] = est->q[2] = est->q[3] = 0.0f;
    for(int i=0; i<3; i++) {
        est->inte_err[i] = 0.0f;
        est->gyro_bias[i] = 0.0f;
    }
	est->gyro_bias[0] = data->Gyro_X;
	est->gyro_bias[1] = data->Gyro_Y;
	est->gyro_bias[2] = data->Gyro_Z;
}

void MPU6050_get_euler_angles(const AttitudeEstimator* est,
                              float* roll, float* pitch, float* yaw)
{
    const float* q = est->q;

    // 横滚角（绕X轴）
    *roll = atan2f(2.0f*(q[0]*q[1] + q[2]*q[3]),
                  1.0f - 2.0f*(q[1]*q[1] + q[2]*q[2]));

    // 俯仰角（绕Y轴）
    float sinp = 2.0f*(q[0]*q[2] - q[3]*q[1]);
    sinp = fminf(fmaxf(sinp, -1.0f), 1.0f);  // 确保asin输入有效
    *pitch = asinf(sinp);

    // 偏航角（绕Z轴）
    *yaw = atan2f(2.0f*(q[0]*q[3] + q[1]*q[2]),
                 1.0f - 2.0f*(q[2]*q[2] + q[3]*q[3]));

    // 转换为角度
    *roll  *= 57.2957795f;
    *pitch *= 57.2957795f;
    *yaw   *= 57.2957795f;
}

/**
 * 用于消除零点漂移的函数。采样1000次。请在2s内不要移动MPU6050.
 * 这个函数不矫正加速度计的数据
 * @param hmpu 要执行矫正操作的MPU6050结构体
 */
void MPU6050_MyCalibrate(MPU6050_HandleTypeDef *hmpu) {

	float gx = 0;
	float gy = 0;
	float gz = 0;
	MPU6050_Data data;
	for(int i = 0 ; i < 1000 ; i++) {
		MPU6050_ReadProcessedData(&hmpu, &data);
		gx+=data.Gyro_X;
		gy+=data.Gyro_Y;
		gz+=data.Gyro_Z;
	}
	zgx = gx / 1000;
	zgy = gy / 1000;
	zgz = gz / 1000;
}


//下面是卡尔曼滤波器


// 初始化滤波器（参数需实验标定）
void Kalman_Init(KalmanFilter *kf) {
	kf->angle = 0.0f;
	kf->rate = 0.0f;
	kf->P[0][0] = 1.0f;  // 初始角度方差
	kf->P[0][1] = 0.0f;
	kf->P[1][0] = 0.0f;
	kf->P[1][1] = 1.0f;  // 初始角速度方差
	kf->Q_angle = 0.001f;// 积分过程噪声
	kf->Q_rate  = 0.003f;// 陀螺仪随机噪声
	kf->R_angle = 0.1f; // 加速度计测量噪声
}

// 预测阶段：使用陀螺仪角速度进行状态预测
void Kalman_Predict(KalmanFilter *kf, float gyro_rate, float dt) {
	/* 状态方程：
	 * angle = angle + (gyro_rate - bias)*dt
	 * 由于零偏已校准，简化为：
	 * angle = angle + gyro_rate*dt
	 * rate = gyro_rate (直接采用测量值)
	 */

	// 更新状态估计
	kf->angle += gyro_rate * dt;
	kf->rate = gyro_rate;

	// 更新协方差矩阵（考虑陀螺仪噪声）
	kf->P[0][0] += dt * (dt*kf->P[1][1] + kf->P[0][1] + kf->P[1][0]) + kf->Q_angle;
	kf->P[0][1] += dt * kf->P[1][1];
	kf->P[1][0] += dt * kf->P[1][1];
	kf->P[1][1] += kf->Q_rate * dt;
}

// 更新阶段：使用加速度计角度校正估计
void Kalman_Update(KalmanFilter *kf, float acc_angle) {

	// 计算残差
	const float y = acc_angle - kf->angle;

	// 计算残差协方差
	const float S = kf->P[0][0] + kf->R_angle;

	// 计算卡尔曼增益
	const float K0 = kf->P[0][0] / S;  // 角度增益
	const float K1 = kf->P[1][0] / S;  // 角速度增益

	// 更新状态估计
	kf->angle += K0 * y;
	kf->rate += K1 * y;

	// 更新协方差矩阵（Joseph形式保证正定性）
	const float P00 = kf->P[0][0];
	const float P01 = kf->P[0][1];

	kf->P[0][0] -= K0 * P00;
	kf->P[0][1] -= K0 * P01;
	kf->P[1][0] -= K1 * P00;
	kf->P[1][1] -= K1 * P01;
}

//辅助函数，用于规范化角度值
float normalize_angle(float angle_deg) {
	angle_deg = fmodf(angle_deg+180.0f,360.0f);
	if(angle_deg<0) angle_deg+=360.0f;
	return angle_deg-180.0f;
}



// 一阶低通滤波
static inline float low_pass_filter(float input, float* state, float alpha) {
   // *state = alpha * (*state) + (1 - alpha) * input;
    //return *state;
	float filtered = alpha*input+(1-alpha)*(*state);
	*state = filtered;
	return filtered;
}

// 一阶高通滤波
static inline float high_pass_filter(float input, float* state, float alpha) {
    //float filtered = input - (alpha * (*state) + (1 - alpha) * input);
	//*state = input;
	float filtered = alpha*input+(1-alpha)*(*state);
	*state = filtered;
    return filtered;
}

EulerAngle gyroAngle;

EulerAngle currentAngle;
int flag = 1;
void MPU6050_update_attitude(EulerAngle *output,float ax, float ay, float az,
                    float gx, float gy, float gz) {
	//[DEBUG]计算处置条件
	gy-=1.8;
	if(flag) {
		gyroAngle.pitch = atanf(ax/sqrtf(ay*ay+az*az))*-57.2957795f;
		gyroAngle.roll = atanf(ay/az)*-57.2957795f;
		currentAngle.pitch = atanf(ax/sqrtf(ay*ay+az*az))*-57.2957795f;
		currentAngle.roll = atanf(ay/az)*-57.2957795f;
		flag = 0;
	}
	// 加速度计低通滤波
	ax = low_pass_filter(ax, &pfp_a.pf[0], ALPHA_LPF);
	ay = low_pass_filter(ay, &pfp_a.pf[1], ALPHA_LPF);
	az = low_pass_filter(az, &pfp_a.pf[2], ALPHA_LPF);
	//对陀螺仪原始信号进行高通滤波
	gx = high_pass_filter(gx, &pfp_g.pf[0], ALPHA_HPF);
	gy = high_pass_filter(gy, &pfp_g.pf[1], ALPHA_HPF);
	gz = high_pass_filter(gz, &pfp_g.pf[2], ALPHA_HPF);


	/*----- 2. 加速度计姿态估计 -----*/

	float pitch_acc,roll_acc;

	//除数判零
	if(fabsf(ay*ay+az*az) > 1e-10 && fabsf(az) > 1e-10) {
		//依赖加速度计解算俯仰角和滚转角
		pitch_acc = atanf(ax/sqrtf(ay*ay+az*az))*-57.2957795f;
		/*
		if(fabsf(ax/0.98)<=1) {
			pitch_acc = asinf(ax/-0.98)*57.2957795f;
		}*/
		roll_acc = atanf(ay/az)*-57.2957795f;
	}

	//自适应更改卡尔曼滤波加速度计噪音
	if(fabsf(ax*ax+ay*ay+az*az)<0.7 || fabsf(ax*ax+ay*ay+az*az)>1.3) {
		kf_pitch.R_angle = 0.2f;
		kf_roll.R_angle = 0.2f;
	}
	else {
		kf_pitch.R_angle = fabsf(ax*ax+ay*ay+az*az-0.98)/10;
		kf_roll.R_angle = fabsf(ax*ax+ay*ay+az*az-0.98)/10;
	}
	//TODO:若除数为0的处理？
	//TODO:若出现极端加速度，应暂时禁用加速度计.

	/*----- 3. 陀螺仪姿态积分 -----*/

	// 判零/规避万向节锁死，然后对陀螺仪的数据进行积分
	if(fabsf(cosf(currentAngle.pitch/57.2957795f))>1e-10) {
		//先进行欧拉角矩阵旋转变换，然后进行陀螺仪积分
		gyroAngle.pitch+=(gy*cosf(currentAngle.roll/57.2957795f)-gz*sinf(currentAngle.roll/57.2957795f))*DT;
		gyroAngle.yaw+=(gy*sinf(currentAngle.roll/57.2957795f)/cosf(currentAngle.pitch/57.2957795f)+gz*cosf(currentAngle.roll/57.2957795f)/cosf(currentAngle.pitch/57.2957795f))*DT;
		gyroAngle.roll+=(gx-gy*sinf(currentAngle.pitch/57.2957795f)*sinf(currentAngle.roll/57.2957795f)/cosf(currentAngle.pitch/57.2957795f)-gz*cosf(currentAngle.roll/57.2957795f)*sinf(currentAngle.pitch/57.2957795f)/cosf(currentAngle.pitch/57.2957795f))*DT;
		//判定积分的欧拉角是否越界并进行纠正
		pitch_acc = normalize_angle(pitch_acc);
		roll_acc = normalize_angle(roll_acc);
		gyroAngle.pitch=normalize_angle(gyroAngle.pitch);
		gyroAngle.yaw=normalize_angle(gyroAngle.yaw);
		gyroAngle.roll=normalize_angle(gyroAngle.roll);
		//卡尔曼滤波融合
		Kalman_Predict(&kf_pitch,gyroAngle.pitch,DT);
		Kalman_Update(&kf_pitch,pitch_acc);
		Kalman_Predict(&kf_roll,gyroAngle.roll,DT);
		Kalman_Update(&kf_roll,roll_acc);


		/*----- 4. 互补滤波融合 -----*/
		//修正互补滤波
		float errorr = normalize_angle(roll_acc-gyroAngle.roll);
		float errorp = normalize_angle(pitch_acc-gyroAngle.pitch);
		float pitch_comp = gyroAngle.pitch+(1.0f-BETA_COMP)*errorp;
		float roll_comp = gyroAngle.yaw+(1.0f-BETA_COMP)*errorr;
		/*
		currentAngle.pitch = pitch_comp;
		currentAngle.roll = roll_comp;
		currentAngle.yaw = gyroAngle.yaw;*/
		currentAngle = MPU6050_GetKalmanAngle();



		output->pitch = pitch_comp;
		output->roll = roll_comp;
		output->yaw = gyroAngle.yaw;
	}
	else {
		output->pitch = currentAngle.pitch;
		output->roll = currentAngle.roll;
		output->yaw = currentAngle.yaw;
	}
}
//[DEBUG]实验性函数。后面要把currentangle改成卡尔曼滤波的输出结果，来增加旋转变换过程的精确度。
EulerAngle MPU6050_GetKalmanAngle() {
	EulerAngle angle;
	angle.yaw = currentAngle.yaw;
	angle.pitch = kf_pitch.angle;
	angle.roll = kf_roll.angle;
	return angle;
}


































//以下为姿态解算部分

static const unsigned char dmpMemory[1929] = {
	/* bank # 0 */
	0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCB, 0x47, 0xA2, 0x20, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
	0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
	0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
	0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
	0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
	/* bank # 1 */
	0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
	0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
	0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x09, 0x23, 0xA1, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
	0x80, 0x00, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
	0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
	/* bank # 2 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x01, 0x00, 0x05, 0x8B, 0xC1, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* bank # 3 */
	0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
	0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
	0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
	0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
	0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
	0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
	0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
	0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0x4C, 0xCD, 0x6C, 0xA9, 0x0C,
	0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
	0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
	0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
	0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
	0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
	0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
	0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
	0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
	/* bank # 4 */
	0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
	0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
	0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
	0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
	0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
	0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
	0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
	0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
	0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
	0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
	0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
	0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
	/* bank # 5 */
	0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
	0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
	0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
	0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
	0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
	0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
	0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
	0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
	0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
	0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
	0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
	0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
	0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
	0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
	0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
	0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
	/* bank # 6 */
	0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
	0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
	0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
	0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
	0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
	0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
	0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
	0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
	0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
	0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
	0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
	0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
	0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
	0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
	0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
	0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
	/* bank # 7 */
	0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
	0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
	0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
	0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
	0xDD, 0xF1, 0x20, 0x28, 0x30, 0x38, 0x9A, 0xF1, 0x28, 0x30, 0x38, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
	0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
	0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0x28, 0x30, 0x38,
	0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0x30, 0xDC,
	0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xFE, 0xD8, 0xFF,

};
// DMP初始化函数
/**
 * DMP初始化函数。注意，当进行MPU姿态解算时，量程最好选2g 、 2000dps。使用4g需要手动调整固件参数；选择其他陀螺仪量程会导致四元数计算错误。
 * @param hmpu
 * @return
 */
uint8_t myMPU6050_DMP_Init(MPU6050_HandleTypeDef *hmpu) {
    uint8_t data[4];
	hmpu->aScale=ACC_SCALE_2G;
	hmpu->gScale=GYRO_SCALE_2000_DPS;
    // 1. 重置设备
    data[0] = 0x80;
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, PWR_MGMT_1, 1, data, 1, 100);
    HAL_Delay(100);

    // 2. 唤醒设备并选择时钟源
    data[0] = 0x03; // PLL with Z axis gyroscope reference
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, PWR_MGMT_1, 1, data, 1, 100);

    // 3. 加载DMP固件。这一步可能需要1秒或者更长
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, 0x6D, 1, (uint8_t*)dmpMemory, 1929, 100);

    // 4. 配置DMP参数
    data[0] = 0x03; // 设置陀螺仪量程±2000dps
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, GYRO_CONFIG, 1, data, 1, 100);

    data[0] = 0x00; // 设置加速度计量程±2g
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, ACCEL_CONFIG, 1, data, 1, 100);

    // 5. 启用DMP功能
    data[0] = 0x02; // 启用FIFO
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, MPU6050_USER_CTRL, 1, data, 1, 100);

    data[0] = 0x78; // 启用DMP和FIFO
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, MPU6050_USER_CTRL, 1, data, 1, 100);

    // 6. 配置FIFO
    data[0] = 0x40; // 启用ACCEL和GYRO_Z
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, MPU6050_FIFO_EN, 1, data, 1, 100);

    // 7. 设置采样率
    data[0] = 4; // 200Hz (200 = 1000/(1 + 4))
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, SMPLRT_DIV, 1, data, 1, 100);

    // 8. 启用中断
    data[0] = 0x02; // FIFO溢出中断
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, MPU6050_INTERRUPT_EN, 1, data, 1, 100);


    hmpu->dmpReady = 1;
    return HAL_OK;
}

// 获取DMP处理后的数据
uint8_t MPU6050_DMP_GetData(MPU6050_HandleTypeDef *hmpu, DMP_Quaternion *q, DMP_Euler_Angles *euler) {
    uint8_t fifoBuffer[64];
    uint16_t fifoCount;

    // 获取FIFO计数
    HAL_I2C_Mem_Read(hmpu->hi2c, hmpu->Address, MPU6050_FIFO_COUNTH, 1, (uint8_t*)&fifoCount, 2, 100);
    fifoCount = (fifoCount >> 8) | (fifoCount << 8); // 转换字节序

    if(fifoCount < 28) return HAL_ERROR;

    // 读取FIFO数据
    HAL_I2C_Mem_Read(hmpu->hi2c, hmpu->Address, MPU6050_FIFO_R_W, 1, fifoBuffer, 28, 100);

    // 解析四元数数据
    q->w = (float)((int32_t)((fifoBuffer[0] << 24) | (fifoBuffer[1] << 16) |
                            (fifoBuffer[2] << 8) | fifoBuffer[3])) / 1073741824.f;//这个值等于2^30
    q->x = (float)((int32_t)((fifoBuffer[4] << 24) | (fifoBuffer[5] << 16) |
                            (fifoBuffer[6] << 8) | fifoBuffer[7])) / 1073741824.f;
    q->y = (float)((int32_t)((fifoBuffer[8] << 24) | (fifoBuffer[9] << 16) |
                            (fifoBuffer[10] << 8) | fifoBuffer[11])) / 1073741824.f;
    q->z = (float)((int32_t)((fifoBuffer[12] << 24) | (fifoBuffer[13] << 16) |
                            (fifoBuffer[14] << 8) | fifoBuffer[15])) / 1073741824.f;

    // 转换为欧拉角
    euler->pitch = atan2(2*(q->w*q->x + q->y*q->z), 1 - 2*(q->x*q->x + q->y*q->y));
    euler->roll = asin(2*(q->w*q->y - q->z*q->x));
    euler->yaw = atan2(2*(q->w*q->z + q->x*q->y), 1 - 2*(q->y*q->y + q->z*q->z));

    // 弧度转角度
    euler->pitch *= 180/M_PI;
    euler->roll *= 180/M_PI;
    euler->yaw *= 180/M_PI;

    return HAL_OK;
}

// 复位FIFO
void MPU6050_DMP_ResetFIFO(MPU6050_HandleTypeDef *hmpu) {
    uint8_t data = 0x04; // FIFO_RESET位
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, MPU6050_USER_CTRL, 1, &data, 1, 100);
    data = 0x40; // 重新启用FIFO
    HAL_I2C_Mem_Write(hmpu->hi2c, hmpu->Address, MPU6050_USER_CTRL, 1, &data, 1, 100);
}


/**
 * 检查指定MPU6050实例的FIFO队列是否已经溢出，如溢出，则自动重置FIFO，以避免OVF。
 * @param hmpu
 */
void MPU6050_DMP_FIFO_CHECK(MPU6050_HandleTypeDef *hmpu) {
	uint8_t int_status;
	HAL_I2C_Mem_Read(hmpu->hi2c, hmpu->Address,
					MPU6050_INT_STATUS, 1,
					&int_status, 1, 100);

	if(int_status & 0x10) { // BIT4=溢出标志
		MPU6050_DMP_ResetFIFO(hmpu);
	}
}
